# name: test/sql/adbc.test
# description: test adbc extension
# group: [sql]

# Before we load the extension, this will fail
statement error
SELECT adbc_connect({'driver': 'test'});
----
Catalog Error: Scalar Function with name adbc_connect does not exist!

# Require statement will ensure this test is run with this extension loaded
require adbc_scanner

require-env HAS_ADBC_SQLITE_DRIVER

# Test that adbc_connect requires 'driver' option (STRUCT syntax)
statement error
SELECT adbc_connect({'uri': 'test'});
----
Invalid Input Error: adbc_connect: 'driver' option is required

# Test that adbc_connect requires 'driver' option (MAP syntax - backwards compatibility)
statement error
SELECT adbc_connect(MAP {'uri': 'test'});
----
Invalid Input Error: adbc_connect: 'driver' option is required

# Test disconnect with invalid handle
statement error
SELECT adbc_disconnect(12345);
----
Invalid Input Error: adbc_disconnect: Invalid connection handle: 12345

# Test adbc_scan with invalid connection handle
statement error
SELECT * FROM adbc_scan(12345, 'SELECT 1');
----
Invalid Input Error: adbc_scan: Invalid connection handle: 12345

# SQLite driver tests - skip if driver not installed
# The driver path may vary by installation, so we use a require statement

statement ok
SET VARIABLE conn_id = (SELECT adbc_connect({'driver': 'sqlite', 'uri': ':memory:'}));

# Test simple SELECT
query II
SELECT * FROM adbc_scan(getvariable('conn_id')::BIGINT, 'SELECT 1 AS a, 2 AS b');
----
1	2

# Test multiple rows
query II
SELECT * FROM adbc_scan(getvariable('conn_id')::BIGINT,
    'SELECT 1 AS id, ''hello'' AS name UNION ALL SELECT 2, ''world'' UNION ALL SELECT 3, ''test'''
) ORDER BY id;
----
1	hello
2	world
3	test

# Test various data types
query IIRR
SELECT * FROM adbc_scan(getvariable('conn_id')::BIGINT,
    'SELECT 42 AS int_col, 9223372036854775807 AS bigint_col, 3.14 AS float_col, 2.718281828 AS double_col'
);
----
42	9223372036854775807	3.14	2.718281828

# Test NULL values
query II
SELECT * FROM adbc_scan(getvariable('conn_id')::BIGINT,
    'SELECT 1 AS a, NULL AS b UNION ALL SELECT NULL, ''test'''
) ORDER BY a NULLS LAST;
----
1	NULL
NULL	test

# Test empty result set
query I
SELECT * FROM adbc_scan(getvariable('conn_id')::BIGINT,
    'SELECT 1 AS a WHERE 1 = 0'
);
----

# Test large result set (more than 4000 rows to test multiple batches)
# SQLite's WITH RECURSIVE generates a sequence of numbers
query II
SELECT COUNT(*), SUM(n) FROM adbc_scan(getvariable('conn_id')::BIGINT,
    'WITH RECURSIVE cnt(n) AS (
        SELECT 1
        UNION ALL
        SELECT n + 1 FROM cnt WHERE n < 5000
    )
    SELECT n, n * 2 AS doubled FROM cnt'
);
----
5000	12502500

# Test parameterized query with a single integer parameter
query I
SELECT * FROM adbc_scan(getvariable('conn_id')::BIGINT, 'SELECT ? AS value', params := row(42));
----
42

# Test parameterized query with multiple parameters of different types
query ITR
SELECT * FROM adbc_scan(getvariable('conn_id')::BIGINT, 'SELECT ? AS a, ? AS b, ? AS c', params := row(123, 'hello world', 2.5::DOUBLE));
----
123	hello world	2.5

# Test parameterized query with NULL parameter
query I
SELECT * FROM adbc_scan(getvariable('conn_id')::BIGINT, 'SELECT ? AS value', params := row(NULL::INTEGER));
----
NULL

# Test parameterized query with multiple parameters including NULL
query II
SELECT * FROM adbc_scan(getvariable('conn_id')::BIGINT, 'SELECT ? AS a, ? AS b', params := row(NULL::INTEGER, 99));
----
NULL	99

# ============================================
# Catalog Functions Tests
# ============================================

# Test adbc_info - returns driver/database info
query II
SELECT * FROM adbc_info(getvariable('conn_id')::BIGINT) WHERE info_name = 'vendor_name';
----
vendor_name	SQLite

# Test adbc_info - all required info fields should be present
query I
SELECT COUNT(*) >= 3 FROM adbc_info(getvariable('conn_id')::BIGINT);
----
true

# Test adbc_tables with empty database (no tables created yet in this connection)
# First get a fresh connection to an in-memory database using MAP syntax (for backwards compatibility testing)
statement ok
SET VARIABLE fresh_conn = (SELECT adbc_connect(MAP {'driver': 'sqlite', 'uri': ':memory:'}));

query I
SELECT COUNT(*) FROM adbc_tables(getvariable('fresh_conn')::BIGINT);
----
0

# Disconnect fresh connection
statement ok
SELECT adbc_disconnect(getvariable('fresh_conn')::BIGINT);

# Test adbc_tables with invalid connection handle
statement error
SELECT * FROM adbc_tables(12345);
----
Invalid Input Error: adbc_tables: Invalid connection handle: 12345

# Test adbc_info with invalid connection handle
statement error
SELECT * FROM adbc_info(12345);
----
Invalid Input Error: adbc_info: Invalid connection handle: 12345

# Test adbc_table_types - returns supported table types (e.g., table, view)
query I
SELECT * FROM adbc_table_types(getvariable('conn_id')::BIGINT) ORDER BY table_type;
----
table
view

# Test adbc_table_types with invalid connection handle
statement error
SELECT * FROM adbc_table_types(12345);
----
Invalid Input Error: adbc_table_types: Invalid connection handle: 12345

# ============================================
# adbc_columns Tests
# ============================================

# Create a table so we have columns to query
statement ok
SET VARIABLE col_conn = (SELECT adbc_connect({'driver': 'sqlite', 'uri': ':memory:'}));

statement ok
SELECT adbc_execute(getvariable('col_conn')::BIGINT, 'CREATE TABLE test_cols (id INTEGER PRIMARY KEY, name TEXT NOT NULL, value REAL)');

# Test adbc_columns - basic query
query IIII
SELECT table_name, column_name, ordinal_position, type_name FROM adbc_columns(getvariable('col_conn')::BIGINT, table_name := 'test_cols') ORDER BY ordinal_position;
----
test_cols	id	1	INTEGER
test_cols	name	2	TEXT
test_cols	value	3	REAL

# Test adbc_columns - filter by column_name
query II
SELECT table_name, column_name FROM adbc_columns(getvariable('col_conn')::BIGINT, table_name := 'test_cols', column_name := 'name');
----
test_cols	name

# Test adbc_columns with invalid connection handle
statement error
SELECT * FROM adbc_columns(12345);
----
Invalid Input Error: adbc_columns: Invalid connection handle: 12345

# Clean up
statement ok
SELECT adbc_disconnect(getvariable('col_conn')::BIGINT);

# ============================================
# adbc_schema Tests
# ============================================

# Create a connection and table for schema tests
statement ok
SET VARIABLE schema_conn = (SELECT adbc_connect({'driver': 'sqlite', 'uri': ':memory:'}));

statement ok
SELECT adbc_execute(getvariable('schema_conn')::BIGINT, 'CREATE TABLE schema_test (id INTEGER, name TEXT, value REAL)');

# Test adbc_schema - get Arrow schema for a table
query I
SELECT field_name FROM adbc_schema(getvariable('schema_conn')::BIGINT, 'schema_test') ORDER BY field_name;
----
id
name
value

# Test adbc_schema with invalid connection handle
statement error
SELECT * FROM adbc_schema(12345, 'test');
----
Invalid Input Error: adbc_schema: Invalid connection handle: 12345

# Clean up
statement ok
SELECT adbc_disconnect(getvariable('schema_conn')::BIGINT);

# ============================================
# adbc_insert Tests (Bulk Ingestion)
# ============================================

# Create a connection for insert tests
statement ok
SET VARIABLE insert_conn = (SELECT adbc_connect({'driver': 'sqlite', 'uri': ':memory:'}));

# Create source data (20,000 rows to test multiple batches)
statement ok
CREATE TABLE insert_source AS SELECT i AS id, 'name_' || i AS name FROM range(20000) t(i);

# Test adbc_insert with create mode
query I
SELECT * FROM adbc_insert(getvariable('insert_conn')::BIGINT, 'bulk_test', (SELECT * FROM insert_source), mode := 'create');
----
20000

# Verify the data was inserted
query I
SELECT COUNT(*) FROM adbc_scan(getvariable('insert_conn')::BIGINT, 'SELECT * FROM bulk_test');
----
20000

# Test adbc_insert with append mode
query I
SELECT * FROM adbc_insert(getvariable('insert_conn')::BIGINT, 'bulk_test', (SELECT * FROM insert_source WHERE id < 1000), mode := 'append');
----
1000

# Verify append worked
query I
SELECT COUNT(*) FROM adbc_scan(getvariable('insert_conn')::BIGINT, 'SELECT * FROM bulk_test');
----
21000

# Test adbc_insert with invalid connection
statement error
SELECT * FROM adbc_insert(12345, 'test', (SELECT 1));
----
Invalid Input Error: adbc_insert: Invalid connection handle: 12345

# Test adbc_insert with invalid mode
statement error
SELECT * FROM adbc_insert(getvariable('insert_conn')::BIGINT, 'test', (SELECT 1), mode := 'invalid');
----
Invalid Input Error: adbc_insert: Invalid mode 'invalid'. Must be one of: create, append, replace, create_append

# Clean up
statement ok
SELECT adbc_disconnect(getvariable('insert_conn')::BIGINT);

statement ok
DROP TABLE insert_source;

# ============================================
# adbc_execute Tests (DDL/DML)
# ============================================

# Get a fresh connection for DDL/DML tests
statement ok
SET VARIABLE exec_conn = (SELECT adbc_connect({'driver': 'sqlite', 'uri': ':memory:'}));

# Test CREATE TABLE
query I
SELECT adbc_execute(getvariable('exec_conn')::BIGINT, 'CREATE TABLE exec_test (id INTEGER PRIMARY KEY, name TEXT)');
----
0

# Test INSERT
query I
SELECT adbc_execute(getvariable('exec_conn')::BIGINT, 'INSERT INTO exec_test VALUES (1, ''hello''), (2, ''world'')');
----
0

# Verify data was inserted
query II
SELECT * FROM adbc_scan(getvariable('exec_conn')::BIGINT, 'SELECT * FROM exec_test ORDER BY id');
----
1	hello
2	world

# Test UPDATE
query I
SELECT adbc_execute(getvariable('exec_conn')::BIGINT, 'UPDATE exec_test SET name = ''updated'' WHERE id = 1');
----
0

# Verify update worked
query II
SELECT * FROM adbc_scan(getvariable('exec_conn')::BIGINT, 'SELECT * FROM exec_test WHERE id = 1');
----
1	updated

# Test DELETE
query I
SELECT adbc_execute(getvariable('exec_conn')::BIGINT, 'DELETE FROM exec_test WHERE id = 2');
----
0

# Verify delete worked
query I
SELECT COUNT(*) FROM adbc_scan(getvariable('exec_conn')::BIGINT, 'SELECT * FROM exec_test');
----
1

# Test adbc_execute with invalid connection handle
statement error
SELECT adbc_execute(12345, 'SELECT 1');
----
Invalid Input Error: adbc_execute: Invalid connection handle: 12345

# Clean up exec_conn
statement ok
SELECT adbc_disconnect(getvariable('exec_conn')::BIGINT);

# ============================================
# Transaction Tests
# ============================================

# Test adbc_commit with invalid connection handle
statement error
SELECT adbc_commit(12345);
----
Invalid Input Error: adbc_commit: Invalid connection handle: 12345

# Test adbc_rollback with invalid connection handle
statement error
SELECT adbc_rollback(12345);
----
Invalid Input Error: adbc_rollback: Invalid connection handle: 12345

# Test adbc_set_autocommit with invalid connection handle
statement error
SELECT adbc_set_autocommit(12345, false);
----
Invalid Input Error: adbc_set_autocommit: Invalid connection handle: 12345

# Create a connection for transaction tests
statement ok
SET VARIABLE tx_conn = (SELECT adbc_connect({'driver': 'sqlite', 'uri': ':memory:'}));

# Create a test table
statement ok
SELECT adbc_execute(getvariable('tx_conn')::BIGINT, 'CREATE TABLE tx_test (id INTEGER, value TEXT)');

# Test rollback - disable autocommit, insert, rollback
query I
SELECT adbc_set_autocommit(getvariable('tx_conn')::BIGINT, false);
----
true

statement ok
SELECT adbc_execute(getvariable('tx_conn')::BIGINT, 'INSERT INTO tx_test VALUES (1, ''will rollback'')');

# Rollback the transaction
query I
SELECT adbc_rollback(getvariable('tx_conn')::BIGINT);
----
true

# Test commit - insert data and commit
statement ok
SELECT adbc_execute(getvariable('tx_conn')::BIGINT, 'INSERT INTO tx_test VALUES (2, ''committed'')');

query I
SELECT adbc_commit(getvariable('tx_conn')::BIGINT);
----
true

# Re-enable autocommit
query I
SELECT adbc_set_autocommit(getvariable('tx_conn')::BIGINT, true);
----
true

# Clean up transaction connection
statement ok
SELECT adbc_disconnect(getvariable('tx_conn')::BIGINT);

# Test disconnect
query I
SELECT adbc_disconnect(getvariable('conn_id')::BIGINT);
----
true

# Test that connection is invalid after disconnect
statement error
SELECT * FROM adbc_scan(getvariable('conn_id')::BIGINT, 'SELECT 1');
----
Invalid Input Error: adbc_scan: Invalid connection handle

# ============================================
# Projection Pushdown Tests
# ============================================

# Create a connection for projection tests
statement ok
SET VARIABLE proj_conn = (SELECT adbc_connect({'driver': 'sqlite', 'uri': ':memory:'}));

# Create a table with 30 columns of various types
statement ok
SELECT adbc_execute(getvariable('proj_conn')::BIGINT, '
    CREATE TABLE wide_table (
        col00 INTEGER, col01 TEXT, col02 REAL, col03 INTEGER, col04 TEXT,
        col05 REAL, col06 INTEGER, col07 TEXT, col08 REAL, col09 INTEGER,
        col10 TEXT, col11 REAL, col12 INTEGER, col13 TEXT, col14 REAL,
        col15 INTEGER, col16 TEXT, col17 REAL, col18 INTEGER, col19 TEXT,
        col20 REAL, col21 INTEGER, col22 TEXT, col23 REAL, col24 INTEGER,
        col25 TEXT, col26 REAL, col27 INTEGER, col28 TEXT, col29 REAL
    )
');

# Insert test data (3 rows)
statement ok
SELECT adbc_execute(getvariable('proj_conn')::BIGINT, '
    INSERT INTO wide_table VALUES
    (0, ''a0'', 0.0, 3, ''a3'', 5.5, 6, ''a6'', 8.8, 9, ''a10'', 11.11, 12, ''a13'', 14.14, 15, ''a16'', 17.17, 18, ''a19'', 20.20, 21, ''a22'', 23.23, 24, ''a25'', 26.26, 27, ''a28'', 29.29),
    (100, ''b0'', 100.0, 103, ''b3'', 105.5, 106, ''b6'', 108.8, 109, ''b10'', 111.11, 112, ''b13'', 114.14, 115, ''b16'', 117.17, 118, ''b19'', 120.20, 121, ''b22'', 123.23, 124, ''b25'', 126.26, 127, ''b28'', 129.29),
    (200, ''c0'', 200.0, 203, ''c3'', 205.5, 206, ''c6'', 208.8, 209, ''c10'', 211.11, 212, ''c13'', 214.14, 215, ''c16'', 217.17, 218, ''c19'', 220.20, 221, ''c22'', 223.23, 224, ''c25'', 226.26, 227, ''c28'', 229.29)
');

# Test 1: Select 5 randomly spaced columns (col02, col07, col15, col22, col28)
query RTITT
SELECT col02, col07, col15, col22, col28 FROM adbc_scan(getvariable('proj_conn')::BIGINT, 'SELECT * FROM wide_table') ORDER BY col02;
----
0.0	a6	15	a22	a28
100.0	b6	115	b22	b28
200.0	c6	215	c22	c28

# Test 2: Select columns in non-sequential order (col28, col03, col19, col10, col00)
query TITII
SELECT col28, col03, col19, col10, col00 FROM adbc_scan(getvariable('proj_conn')::BIGINT, 'SELECT * FROM wide_table') ORDER BY col00;
----
a28	3	a19	a10	0
b28	103	b19	b10	100
c28	203	c19	c10	200

# Test 3: Select only first column
query I
SELECT col00 FROM adbc_scan(getvariable('proj_conn')::BIGINT, 'SELECT * FROM wide_table') ORDER BY col00;
----
0
100
200

# Test 4: Select only last column
query R
SELECT col29 FROM adbc_scan(getvariable('proj_conn')::BIGINT, 'SELECT * FROM wide_table') ORDER BY col29;
----
29.29
129.29
229.29

# Test 5: Select first and last columns
query IR
SELECT col00, col29 FROM adbc_scan(getvariable('proj_conn')::BIGINT, 'SELECT * FROM wide_table') ORDER BY col00;
----
0	29.29
100	129.29
200	229.29

# Test 6: Select all columns (no projection - verify full result)
query I
SELECT COUNT(*) FROM adbc_scan(getvariable('proj_conn')::BIGINT, 'SELECT * FROM wide_table');
----
3

# Test 7: Aggregation with projection (only needs one column)
query IR
SELECT COUNT(*), SUM(col00) FROM adbc_scan(getvariable('proj_conn')::BIGINT, 'SELECT * FROM wide_table');
----
3	300

# Test 8: Projection with WHERE clause (filter uses projected column)
query IT
SELECT col00, col01 FROM adbc_scan(getvariable('proj_conn')::BIGINT, 'SELECT * FROM wide_table') WHERE col00 > 50 ORDER BY col00;
----
100	b0
200	c0

# Test 9: Projection with expressions
query IIR
SELECT col00, col00 * 2 AS doubled, col02 + col05 AS sum_reals FROM adbc_scan(getvariable('proj_conn')::BIGINT, 'SELECT * FROM wide_table') ORDER BY col00;
----
0	0	5.5
100	200	205.5
200	400	405.5

# Test 10: Select same column multiple times (edge case)
query III
SELECT col00, col00, col00 FROM adbc_scan(getvariable('proj_conn')::BIGINT, 'SELECT * FROM wide_table') ORDER BY col00;
----
0	0	0
100	100	100
200	200	200

# Test 11: Large number of rows with projection (test batching)
statement ok
SELECT adbc_execute(getvariable('proj_conn')::BIGINT, 'CREATE TABLE large_wide (c0 INT, c1 INT, c2 INT, c3 INT, c4 INT, c5 INT, c6 INT, c7 INT, c8 INT, c9 INT)');

statement ok
SELECT adbc_execute(getvariable('proj_conn')::BIGINT, '
    WITH RECURSIVE cnt(n) AS (
        SELECT 0
        UNION ALL
        SELECT n + 1 FROM cnt WHERE n < 9999
    )
    INSERT INTO large_wide SELECT n, n+1, n+2, n+3, n+4, n+5, n+6, n+7, n+8, n+9 FROM cnt
');

# Select only 2 columns from 10, with 10000 rows
query II
SELECT SUM(c0), SUM(c9) FROM adbc_scan(getvariable('proj_conn')::BIGINT, 'SELECT * FROM large_wide');
----
49995000	50085000

# Select columns at various positions
query III
SELECT SUM(c1), SUM(c5), SUM(c8) FROM adbc_scan(getvariable('proj_conn')::BIGINT, 'SELECT * FROM large_wide');
----
50005000	50045000	50075000

# Test 12: Projection with NULL values
statement ok
SELECT adbc_execute(getvariable('proj_conn')::BIGINT, 'CREATE TABLE null_test (a INT, b TEXT, c REAL, d INT, e TEXT)');

statement ok
SELECT adbc_execute(getvariable('proj_conn')::BIGINT, '
    INSERT INTO null_test VALUES
    (1, NULL, 1.1, NULL, ''e1''),
    (NULL, ''b2'', NULL, 4, NULL),
    (3, ''b3'', 3.3, 6, ''e3'')
');

# Select columns with NULLs at various positions
query ITI
SELECT a, b, d FROM adbc_scan(getvariable('proj_conn')::BIGINT, 'SELECT * FROM null_test') ORDER BY a NULLS LAST;
----
1	NULL	NULL
3	b3	6
NULL	b2	4

# Select only columns that have NULLs
query TR
SELECT b, c FROM adbc_scan(getvariable('proj_conn')::BIGINT, 'SELECT * FROM null_test') ORDER BY c NULLS LAST;
----
NULL	1.1
b3	3.3
b2	NULL

# Test 13: Count with no columns (just counting rows)
query I
SELECT COUNT(*) FROM adbc_scan(getvariable('proj_conn')::BIGINT, 'SELECT * FROM null_test');
----
3

# Clean up projection connection
statement ok
SELECT adbc_disconnect(getvariable('proj_conn')::BIGINT);

# ============================================
# SECRETS TESTS
# ============================================

# Test creating an ADBC secret with scope
statement ok
CREATE SECRET my_sqlite_secret (
    TYPE adbc,
    SCOPE 'sqlite://:memory:',
    driver 'sqlite',
    uri ':memory:'
);

# Test connecting using a secret by URI scope
statement ok
SET VARIABLE secret_conn = (SELECT adbc_connect({'uri': 'sqlite://:memory:'}));

# Verify the connection works
query II
SELECT * FROM adbc_scan(getvariable('secret_conn')::BIGINT, 'SELECT 1 AS a, 2 AS b');
----
1	2

# Clean up
statement ok
SELECT adbc_disconnect(getvariable('secret_conn')::BIGINT);

# Test connecting with explicit secret name
statement ok
CREATE SECRET named_sqlite_secret (
    TYPE adbc,
    SCOPE 'sqlite://named',
    driver 'sqlite',
    uri ':memory:'
);

statement ok
SET VARIABLE named_conn = (SELECT adbc_connect({'secret': 'named_sqlite_secret'}));

# Verify the connection works
query II
SELECT * FROM adbc_scan(getvariable('named_conn')::BIGINT, 'SELECT 3 AS x, 4 AS y');
----
3	4

# Clean up
statement ok
SELECT adbc_disconnect(getvariable('named_conn')::BIGINT);

# Test that explicit options override secret options
statement ok
CREATE SECRET override_test_secret (
    TYPE adbc,
    SCOPE 'sqlite://override',
    driver 'sqlite',
    uri '/nonexistent/path.db'
);

# The explicit uri should override the secret's uri (which would fail)
statement ok
SET VARIABLE override_conn = (SELECT adbc_connect({'secret': 'override_test_secret', 'uri': ':memory:'}));

query I
SELECT * FROM adbc_scan(getvariable('override_conn')::BIGINT, 'SELECT 42 AS val');
----
42

statement ok
SELECT adbc_disconnect(getvariable('override_conn')::BIGINT);

# Test error when referencing non-existent secret by name
statement error
SELECT adbc_connect({'secret': 'nonexistent_secret'});
----
Binder Error: Secret with name "nonexistent_secret" not found

# Test extra_options for driver-specific parameters
statement ok
CREATE SECRET extra_opts_secret (
    TYPE adbc,
    SCOPE 'sqlite://extra',
    driver 'sqlite',
    uri ':memory:'
);

statement ok
SET VARIABLE extra_conn = (SELECT adbc_connect({'uri': 'sqlite://extra'}));

query I
SELECT * FROM adbc_scan(getvariable('extra_conn')::BIGINT, 'SELECT 100 AS val');
----
100

statement ok
SELECT adbc_disconnect(getvariable('extra_conn')::BIGINT);

# Clean up secrets
statement ok
DROP SECRET my_sqlite_secret;

statement ok
DROP SECRET named_sqlite_secret;

statement ok
DROP SECRET override_test_secret;

statement ok
DROP SECRET extra_opts_secret;
